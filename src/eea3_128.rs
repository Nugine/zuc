#![allow(unused_imports, unused_variables)]

use std::ops::BitXor;
use bytemuck::cast_slice;
use crate::ZUC128;

fn encryption_xor(ck: u128, iv: u128, length: u32, ibs: &[u8]) -> Vec<u8> {
    let l = (length + 31) / 32;

    let ck = ck.to_be_bytes();
    let iv = iv.to_ne_bytes();

    println!("CK: ");
    print_arr_u8(&ck);
    println!("IV: ");
    print_arr_u8(&iv);

    let mut zuc = ZUC128::new(&ck, &iv);
    let mut keys = (0..l)
                            .flat_map(|_| {
                                let z = zuc.generate().to_be();
                                [ z as u8, (z >> 8)  as u8, (z >> 16) as u8, (z >> 24) as u8]
                            })
                            .collect::<Vec<u8>>();

    keys.truncate(length as usize / 8 + 1);
    if length % 8 != 0 {
        keys[length as usize / 8] &= 0xFF << (8 - length % 8);
    }
    keys.extend(std::iter::repeat(0x0).take(ibs.len() - keys.len()));

    let mut res = ibs.to_vec();
    res.iter_mut().zip(keys.iter()).for_each(|(ib, k)| { *ib ^= k; });
    println!("RES: ");
    print_vec_u8(&res);
    res
}

fn eea3_128(count: u32, bearer: u32, direction: u32, ck: u128, length: u32, ibs: &[u8]) -> Vec<u8> {
    // init
    let bearer = bearer as u8 & ((1 << 6) - 1);
    let direction = direction as u8 & 0x1;

    let mut iv = [0_u8; 16];
    iv[0] = (count >> 24) as u8;
    iv[1] = (count >> 16) as u8;
    iv[2] = (count >> 8) as u8;
    iv[3] = count as u8;
    iv[4] = bearer << 3 | direction << 2 | 00;
    iv[5..=7].fill(0x0);
    let tmp = &iv[0..8].to_vec();
    iv[8..16].copy_from_slice(&tmp);

    println!("IV: "); // CHECK
    print_arr_u8(&iv);

    encryption_xor(ck, u128::from_ne_bytes(iv), length, ibs)
}


fn print_vec_u8(vec: &Vec<u8>) {
    vec.iter().for_each(|x| print!("{:02x} ", x));
    println!()
}
fn print_arr_u8(vec: &[u8]) {
    vec.iter().for_each(|x| print!("{:02x} ", x));
    println!()
}

#[cfg(test)]
mod tests {
    use std::fmt::Debug;
    use bytemuck::{cast_slice, Pod};
    use crate::eea3_128::{eea3_128, print_arr_u8, print_vec_u8};
    use crate::ZUC128;

    #[test]
    fn test_1() { // 3GPP LTE Example 1
        let ck: u128 = 0x17_3d_14_ba_50_03_73_1d_7a_60_04_94_70_f0_0a_29;
        let count: u32 = 0x66035492;
        let bearer: u32 = 0xf;
        let direction: u32 = 0;
        let length: u32 = 0xc1;
        let ibs: [u8; 28] = [
            0x6c, 0xf6, 0x53, 0x40, 0x73, 0x55, 0x52, 0xab, 0x0c, 0x97, 0x52, 0xfa, 0x6f, 0x90, 0x25,
            0xfe, 0x0b, 0xd6, 0x75, 0xd9, 0x00, 0x58, 0x75, 0xb2, 0x00, 0x00, 0x00, 0x00,
        ];
        let obs: [u8; 28] = [
            0xa6, 0xc8, 0x5f, 0xc6, 0x6a, 0xfb, 0x85, 0x33, 0xaa, 0xfc, 0x25, 0x18, 0xdf, 0xe7, 0x84,
            0x94, 0x0e, 0xe1, 0xe4, 0xb0, 0x30, 0x23, 0x8c, 0xc8, 0x00, 0x00, 0x00, 0x00
        ];

        assert_eq!(
            eea3_128(count, bearer, direction, ck, length, &ibs),
            cast_slice(&obs[..])
        )
    }

    #[test]
    fn test_2() { // 3GPP LTE Example 2
        let       ck: u128  = 0xe5_bd_3e_a0_eb_55_ad_e8_66_c6_ac_58_bd_54_30_2a;
        let     count  = 0x56823;
        let    bearer  = 0x18;
        let direction  = 0x1;
        let    length  = 0x320;
        let ibs:[u8; 100] = [
            0x14, 0xa8, 0xef, 0x69,     0x3d, 0x67, 0x85, 0x07,
            0xbb, 0xe7, 0x27, 0x0a,     0x7f, 0x67, 0xff, 0x50,
            0x06, 0xc3, 0x52, 0x5b,     0x98, 0x07, 0xe4, 0x67,
            0xc4, 0xe5, 0x60, 0x00,     0xba, 0x33, 0x8f, 0x5d,
            0x42, 0x95, 0x59, 0x03,     0x67, 0x51, 0x82, 0x22,
            0x46, 0xc8, 0x0d, 0x3b,     0x38, 0xf0, 0x7f, 0x4b,
            0xe2, 0xd8, 0xff, 0x58,     0x05, 0xf5, 0x13, 0x22,
            0x29, 0xbd, 0xe9, 0x3b,     0xbb, 0xdc, 0xaf, 0x38,
            0x2b, 0xf1, 0xee, 0x97,     0x2f, 0xbf, 0x99, 0x77,
            0xba, 0xda, 0x89, 0x45,     0x84, 0x7a, 0x2a, 0x6c,
            0x9a, 0xd3, 0x4a, 0x66,     0x75, 0x54, 0xe0, 0x4d,
            0x1f, 0x7f, 0xa2, 0xc3,     0x32, 0x41, 0xbd, 0x8f,
            0x01, 0xba, 0x22, 0x0d,
        ];
        let obs:[u8; 100] = [
            0x13, 0x1d, 0x43, 0xe0,     0xde, 0xa1, 0xbe, 0x5c,
            0x5a, 0x1b, 0xfd, 0x97,     0x1d, 0x85, 0x2c, 0xbf,
            0x71, 0x2d, 0x7b, 0x4f,     0x57, 0x96, 0x1f, 0xea,
            0x32, 0x08, 0xaf, 0xa8,     0xbc, 0xa4, 0x33, 0xf4,
            0x56, 0xad, 0x09, 0xc7,     0x41, 0x7e, 0x58, 0xbc,
            0x69, 0xcf, 0x88, 0x66,     0xd1, 0x35, 0x3f, 0x74,
            0x86, 0x5e, 0x80, 0x78,     0x1d, 0x20, 0x2d, 0xfb,
            0x3e, 0xcf, 0xf7, 0xfc,     0xbc, 0x3b, 0x19, 0x0f,
            0xe8, 0x2a, 0x20, 0x4e,     0xd0, 0xe3, 0x50, 0xfc,
            0x0f, 0x6f, 0x26, 0x13,     0xb2, 0xf2, 0xbc, 0xa6,
            0xdf, 0x5a, 0x47, 0x3a,     0x57, 0xa4, 0xa0, 0x0d,
            0x98, 0x5e, 0xba, 0xd8,     0x80, 0xd6, 0xf2, 0x38,
            0x64, 0xa0, 0x7b, 0x01
        ];

        assert_eq!(
            eea3_128(count, bearer, direction, ck, length, &ibs),
            cast_slice(&obs)
        );
    }
}